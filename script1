Hi, my name's Jeremie and I'm the original author of jbuilder, a
build system for OCaml and Reason. In this video, I'm going to show
how to get started with jbuilder. I'm going to I'm going to walk you
step by step into specifying a project so that it can be built and
tested with jbuilder. Following this video there will be a second one
showing how to package the project so that it can be distributed to a
package manager such as opam.

I'm going to use is a toy project, which is composed of a small math
library, some tests and a command line tool exposing the functions of
the library to the shell. This project is written in OCaml, but what
I'm going to describe would be the same for a Reason project.

Before we look more in detail at the project itself, the first thing
we need to do is delimit what we call the workspace. Like with any
build system, the file system is split into two parts: one parts that
contains source files that we want to build, and the rest of the file
system, which we take as read only and typically contains pre-built
binaries, such as compilers and pre-built libraries, typically
installed by a package manager.

With jbuilder, we'll call the first part the "workspace" and the
second part the "installed world". The way to delimit them is to
create a jbuild-workspace file, which will define the root of the
workspace. Such a file is actually a configuration file and when it is
empty the default configuration is used, which is what we want in this
video.

For instance, if I go in a sub-directory and type "jbuilder build", it
prints "Entering directory" following by the root of the
workspace. Note that it only prints it when the root is not the
current directory.

You can nest workspaces, and when several choices are possible,
jbuilder will always choose the biggest workspace. For instance, if I
create a jbuild-workspace file in my sub-directory, jbuilder will
still pick up the same root as before. The reaon for this is that it
is very common to create big workspaces containing several
projects. Typically, when working on several projects that depend on
each others, it is common to put them all in the same workspace so
that changes to one project are immediatly picked up by the others.

So far we've seen how delimit the set of files we want to work
on. That's all the setup we need to start using jbuilder. Now let's
move on to the next part and see how we can describe our project to
jbuilder.

We are going to start with the "src" directory that contains our
library. For this library we have a math.mli file that contains the
public interface, this is what user code will have access to, and the
various functions are implemented in other files. Eventually we also
want the primes100.ml file to be generated by the program in the gen
sub-directory. For now I have included the generated file and we'll
see later how ask jbuilder to generate it on the fly.

So to describe this library we need to write a "jbuild" file. "jbuild"
files are what jbuilder reads metadata from, in fact that's where the
name "jbuilder" comes from, the "j" coming from jenga, which is
another build system that inspired jbuilder.

These jbuild files are written in S-expression syntax. I'm going to
first quickly describe this syntax in case you don't know it. The
S-expression syntax is very simple: everything is either an atom or a
list. Atoms are simply strings and when they are simple they can just
be written as it. For instance "hello" is an atom. When they contains
spaces or special characters, they must be enclosed in
double-quotes. For instance "Hello, world!" is another atom.

Lists are written by writing the elements separated by spaces between
parentheses. For instance, this is the list "a b c". Lists can be
nested. Essentially S-expressions allow to represent arbitrary data
trees.  Lastly, you can comment a line with a semilicolon.

Now back to jbuild files. They are composed of stanzas, each stanza
being a list that start with a keyword. Typically, all jbuilder files
will start a "jbuild_version" stanza, which indicate which version of
the specification we are using. If we ever introduce breaking changes,
this number will increase. Note that this stanza might change when we
add support for plugins in jbuilder, as we might want to specify the
versions of the plugins we are using.

So back to our project, we want to say that this directory contains a
library, and we do that with a "library" stanza. This stanza contains
a list of fields that describe the library. Typically we must have a
"name" field. The name we write here is the name that we will use in
source code that use this library, so it has to be a valid OCaml
module name. It doesn't have to start with a capital letter, however
it cannot contain special characters such as dashes or dots. Here the
name correspond to the "math" module I showed you earlier.

Then we are going to add a one liner description with a "synopsis"
field. It is not mandatory, but it is good practice to have one. In
particular it is used when we list the pre-compiled libraries that are
part of the installed world.

Now that we did that, we can ask jbuilder to build this
library. Simply building it is not very interesting, however one thing
that we do often in OCaml is try the code in the interactive
toplevel. This is very easy to do with jbuilder, all we have to do
type "jbuilder utop" and we'll get a toplevel session where our lirary
is ready to use. The command is called "utop" as it uses "utop", which
is an improved toplevel for OCaml. So you will need to install it
first, typically with opam.

So let's try it. As you can see I can call the "Math.fact" function
and get the result.

Before we move on to the rest of the project, I'd like to show you one
detail about libraries. For this library we have a module "math",
which jbuilder will use as the interface of the library but you don't
need to have one. If we don't have it, jbuilder will automatically
create one composed of all the modules of the library.

For instance if I delete the files for the Math module and run utop
again, I now have a Math.Fact module but no longer a Math.fact
function.

That's all for now for the library. Let's restore the files and move
on the next part: the command line tool. As before we are going to
write a jbuild file in the bin directory. It starts again with a
"jbuild_version" stanza and this time we have an "executable"
stanza. We again have a "name" field, which points to the module that
contains the entry point of our program. If we had several
executables, we could use an "executables" stanza which would have a
"names" field. Note that we only need to list the modules that contain
the entry points, we can have other modules in the same directory and
use them but we don't need to list them.

Then, because we are using librarires in this executable, we need to
add a "libraries" field. It contains "math", which is the library we
just defined, as well as "cmdliner", which is a library used to create
comand line tools. This library is not part of the workspace, so
jbuilder will look for it in the installed world. However, if we
unpacked the sources of cmdliner in the workspace, jbuilder would
immediately pick them up.

Now we can ask jbuilder to build this executable with "jbuilder build
bin/cli.exe". Jbuilder puts artifacts in a separate build directory,
so there are no files where created in the bin directory. We can use
the command "jbuilder exec" to run our freshly compiled binary. At the
time of recording this video, this feature is not yet released. I'm
using a developpment version of jbuilder.

Now that we know how to define executables with jbuilder, let's go
back to the library and see how we can generate the primes100
module. So I'm going to start by deleting the file for this module,
and as you can see the build is now failing.

The first thing we need to do is to declare the generator to jbuilder,
by writing a jbuild file in src/jbuild. Now that this is done, we need
to tell jbuilder to use this binary to produce the primes100.ml file.
We do that by editing src/jbuild and adding a "rule" stanza. The
"rule" stanza allows us to add custom build rules to jbuilder. Here
our rule stanza only contains the following action: running the
genererator and dumping it's standard output to a file.

The action is written using a small DSL, contrary to other build
systems jbuilder doesn't encourage the use of an external shell. This
is because we want a native experience on all platforms and such
external shells are usually not fully portable, especially on
Windows. On the other hand, this DSL is interpreted natively on all
supported platforms.

Note that we only wrote an action, and we didn't specify it's
dependencies and targets. This is because these are obvious by just
looking at the action. If they weren't we would need to specify them
using the full form of the "rule" stanza which has three field
"targets", "deps" and "action". This one is a shorter form for simple
rules.

Now if I try again to build the command line tool, it succeeds and we
can see a line in the ouput that contains the call to our generator.

Now that we have seen how to add custom rules to jbuilder, let's look
at the last part, the tests. They are written as an executable that
does some assertions. We need two things: tell jbuilder about this
executable and tell jbuilder that we want to run it as part of running
the tests.

The first part is the same as before. For the second, we are going to
add the action of running the binary to the "runtest" alias. In
jbuilder aliases are names that refer to sets of files and actions to
run. We can extend an alias in a given directory with an "alias"
stanza. We need to give the name of the alias, here "runtest" and the
action to run.

For the action, we are using a small DSL. We don't use an external
shell as typically done in other build systems. The reason is that
such shells are usually not fully portable, in particular under
Windows. On the other hand, this DSL is implemented natively on all
supported platofrms.

Note that if my tests was reading files, I would need to specify them
as dependencies with a "deps" field.

To run the tests, we need to ask jbuilder to build the runtest
alias. To do that we have to write "runtest" prefixed by an "at". This
instructs jbuilder to build the runtest alias recursively in all
directories starting from the current one. Since this is a very common
operation, there is a shorthand for it, we can simply write "jbuilder
runtest".

To show that the test is indeed run, I'm going to make it fail. If I
do "jbuilder runtest" again, we can see that the test is failing.

That's all for this video. We have seen how to descriibe a project in
terms of libraries, executables, tests and custom build rules. There
are many features of jbuilder I haven't talked about, you can find
more about them in the online manual. The main part we haven't seen is
how to package our project, as in OCaml we often want to distribute
our code through the opam package manager. That we'll be covered in
another video.

But I hope that this video will help you understand better how
jbuilder works and how you can use it to do OCaml development. If you
have questions, don't hesitate to ask, either on the github project or
on discuss.ocaml.org.
