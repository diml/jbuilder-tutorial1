Hi, my name is Jeremie and I'm the original author of jbuilder, a
build system for OCaml and Reason. In this video, I'm going to show
how to get started with jbuilder. In the first part I'm going to show
how to setup jbuilder, in the scond part I'm going to walk you step by
step into specifying a project so that it can be built and tested with
jbuilder, and in the third part I will show how to package it so that
it can be distributed and installed by users.

I'm going to use is a toy project, which is composed of a small math
library, some tests and a command line tool exposing the functions of
the library to the shell.

Let's look at the first part, the setup.

The first thing to do when starting to use jbuilder is to delimit what
we'll call the workspace. Like with any build system, the file system
is split into two parts: one parts that contains source files that we
want to build, and the rest of the file system, which we take as read
only and typically contains pre-built binaries, such as compilers and
pre-built libraries, typically installed by a package manager.

With jbuilder, we'll call the first part the "workspace" and the
second part the "installed world". The way to delimit them is to
create a jbuild-workspace file, which will define the root of the
workspace. Such a file is actually a configuration file and when it is
empty the default configuration is used, which is what we want in this
video.

For instance, if I go in a sub-directory and type "jbuilder build", it
prints "Entering directory" following by the root of the
workspace. Note that it only prints it when the root is not the
current directory.

You can nest workspaces, and when several choices are possible,
jbuilder will always choose the biggest workspace. For instance, if I
create a jbuild-workspace file in my sub-directory, jbuilder will pick
up the same root. The reaon for this is that it is very common to
create big workspaces containing several projects. Typically, when
working on several projects that depend on each others, it is common
to put them all in the same workspace so that changes to one project
are immediatly picked up by the others.

That's all we need for the setup. Now let's move on to the second part
and see how we can describe our project to jbuilder.

Jbuilder reads metadata from "jbuild" files, in fact that's where the
name jbuilder comes from, the "j" coming from jenga, which is another
build system that inspired jbuilder.

These jbuild files are written in S-expression syntax. The
S-expression syntax is very simple: everything is either an atom or a
list. Atoms are simply strings and when they are simple they can just be
written as it. For instance "hello" is an atom. When they contains
spaces or special characters, they must be enclosed in
double-quotes. For instance "Hello, world!" is another atom.

Lists are written by writing the elements separated by spaces between
parentheses. For instance, this is the list "a b c". Lists can be
nested. Essentially S-expressions represent arbitrary data trees.
Lastly, you can comment a line with a semilicolon.

Now back to jbuild files. They are composed of stanzas, each stanza
being a list that start with a keyword. Typically, all jbuilder files
will start a "jbuild_version" stanza, which indicate which version of
the specification we are using. If we ever introduce breaking changes,
this number will increase. This stanza might change when we add
support for plugins in jbuilder, as we might want to specify the
versions of the plugins we are using.

We want to say that this directory contains a library, and we do that
with a "library" stanza which contains a list of fields. Typically we
must have a "name" field. The name we write here is the name that we
will use in source code that use this library, so it has to be a valid
OCaml module name. It doesn't have to start with a capital letter,
however it cannot contain special characters such as dashes or dots.

Then we are going to add a one liner description with a "synopsis"
field. It is not mandatory, but it is good practice to have one. In
particular it is used when we list the libraries that are part of the
installed world.

Now that we did that, we can ask jbuilder to build this
library. Simply building it is not very interesting, one thing that we
do often in OCaml is try the code in the interactive toplevel. This is
easy to do with jbuilder, all you have to do type "jbuilder utop" and
we'll get a toplevel session where the libraries defined in the
current directory are ready to use. The command is called "utop" as it
uses the "utop" package, which is an improved toplevel for OCaml. So
you will need to install it first, typically with opam.

So let's try. As you can see I can call the "Math.fact" function and
get the result.

Before we move on to the rest of the project, I'd like to show you one
detail about libraries. For this library we have a module "math",
which jbuilder will use as the interface of the library but you don't
need to have one. If we don't have it, jbuilder will automatically
create one composed of all the modules of the library.

For instance if I delete the files for the Math module and run utop
again, I now have a Math.Fact module but no longer a Math.fact
function.

Let's restore the files and move on the next part: the command line
tool. As before we are going to write a jbuild file in the bin
directory. It starts again with a "jbuild_version" stanza and this
time we have an "executable" stanza. We again have a "name" field,
which points to the module that contains the entry point of our
program. If we had several executables, we could use an "executables"
stanza which would have a "names" field. Note that we only need to
list the modules that contain the entry points, we can have other
modules in the same directory and use them but we don't need to list
them.

Then, because we are using librarires in this executable, we need to
add a "libraries" field. It contains "math", which is the library we
just defined as well a "cmdliner", which is a library used to create
comand line tools. This library is not part of the workspace, so
jbuilder will look for it in the installed world. However, if we
unpacked the sources of cmdliner in the workspace, jbuilder would
immediately pick it up.

Now we can ask jbuilder to build this executable with "jbuilder build
bin/cli.exe". Jbuilder puts artifacts in a separate build directory,
so no files where created in the bin directory and we can use the
command "jbuilder exec" to run our freshly compiled binary. At the
time of recording this video, this feature is not yet released. I'm
using a developpment version of jbuilder.

Now let's look at the last part, the tests. They are written as an
executable that does some assertions. We need two things: tell
jbuilder about this executable and tell jbuilder that we want to run
it as part of running the tests.

The first part is the same as before. For the second, we are going to
add the action of running the binary to the "runtest" alias. In
jbuilder aliases are names that refer to sets of files and actions to
run. We can extend an alias in a given directory with an "alias"
stanza. We need to give the name of the alias, here "runtest" and the
action to run.

For the action, we are using a small DSL. We don't use an external
shell as typically done in other build systems. The reason is that
such shells are usually not fully portable, in particular under
Windows. On the other hand, this DSL is implemented natively on all
supported platofrms.

Note that if my tests was reading files, I would need to specify them
as dependencies with a "deps" field.

To run the tests, we need to ask jbuilder to build the runtest
alias. To do that we have to write "runtest" prefixed by an "at". This
instructs jbuilder to build the runtest alias recursively in all
directories starting from the current one. Since this is a very common
operation, there is a shorthand for it, we can simply write "jbuilder
runtest".

To show that the test is indeed run, I'm going to make it fail. If I
do "jbuilder runtest" again, we can see that the test is failing.

That's all for the second part of this video. We have seen to describe
our project in terms of libraries, executables and tests. Now we are
going to see how to package our project with jbuilder.

What we mean by a package is a set of libraries, executables and other
files that will be installed together on the user machine, typically
by using a package manager such as opam.

We can have multiple packages in the same project. In particular in
this example we are going to have two packages: one called "math" for
the library and one called "math-bin" for the command line tool
together with a manual page. The reason we typically want to have
several packages is to have more fine grained dependencies, since
package managers can only install whole packages at once. If we were
defining a single package, whenever someone would want to use the
"math" library, they would end up having to install the "cmdliner"
package as well, even though they might not the command line tool.

The first step is to tell jbuilder about the two packages we want to
define. This is not done in jbuild files. The reason is that these
packages will be distributed through the opam package manager, and to
do so we will have to write package.opam files. So to avoid
duplicating the information, jbuilder simply acknowledges the presence
of these package.opam files.

So we are going to create these two files. I'm starting by writing the
information that is not relevant to the build of these packages such
as the homepage or the maintainer. In particular, for now these two
files are identical. There is a bit of duplication here, the reason
for that is that when opam started projects were typically composed of
a single package and that was because it was complicated to setup the
build of multi-package projects. However, it is really simple to do so
with jbuilder.

Now that we have added these opam files, we can add components to
these two packages. Wwe can only declare components in a certain scope
and not in the whole workspace. This scope is the sub-tree that starts
where these two opam files live, excluding any other sub-scope. This
is to ensure that when we have several projects in the same workspace
they don't overlap.

For instance, let's add the library to the "math" package. For that we
simply have to add a public name to the library. This public name is
the name that we'll have to write in jbuild files of other projects
when we want to use the "math" library. It must start with the package
name, so "math", and can be followed by a dot and anything else we
want. This allows to put several libraries in the same package. The
name and public name are often the same, however they might be
different, typically when the package is not a valid module name, for
instance if it contains a dash.

Libraries that don't have a public name are private, and can only be
used in the scope where they are defined. In particular it is ok to
have several private libraries with the same name inside the same
workspace, as long as they are in different scopes. This often happens
when we have several projects in the same workspace. Public library
names on the contrary must be unique.

Now let's look at the "math-bin" package. Same as for the library, we
simply a public name to the executable. This name is the name under
which the binary will be installed in the bin directory and can be
used from the shell. It can be anything and doesn't have to start with
the package name.

Since we have two packages in the current scope, we must tell which
package this binary is part of by adding a "package" field. If we had
only one, we wouldn't need to.

Another thing we want to add in the "math-bin" package is a manual
page so that the user can do "man math". The manual page can be
generated directly from the executable, this is feature of
cmdliner. However, jbuilder doesn't know about cmdliner, so creating
this manual page is not a builtin. We have to use a custom rule to do
it.

Custom rules are specified with a "rule" stanza. Here we simply write
the action using the same DSL as for the alias stanza and the
"with-stdout-to" form allows to dump the output of a command to a
file. Note that we say "run math" rather than "run
./cli.exe". Normally, jbuilder would resolve this "math" name in the
same way as a shell: it would look it up in the PATH. However, since
it knows that we are installing a math binary, it will resolve to the
the local binary rather than looking it up the PATH.

Here the dependencies and targets of the rule are obvious from the
action. If they were not, we would have to specify them
explicitely. In fact, this form is the short version of the "rule"
stanza. It normally has "targets", "deps" and "action" fields.

Now that we know how to create this file, we need to tell jbuilder to
install it by writing an "install" stanza. It starts with a section,
which for instance can be "bin", "lib", "doc" or other things. Here we
want the "man" section which is for installing manual pages. We need
to disambiguate the package as well so we write "package math-bin"
again. Lastly we specify the list of files to install.

For tests, there is nothing to install. However, often package
managers allow to specify how to run the tests for a package. We don't
want the tests to be run for both packages. Since they are only
testing the library, we specify that they are part of the "math"
package.

Now that we have done all that, we can ask jbuilder to build the
package.install files. This causes jbuilder to build everything that
needs to be installed and generate a package.install file containing
the list of files to install.

For instance if we ask jbuilder to build math.install, it will build a
few more things that needs to be installed. Typically here it built a
few more files that we didn't needed so far but might be needed by
users of the library once it is installed. And math.install contains
the list of files to install for the "math" package. We can do the
same for the "math-bin" package, and we can see our binary, our manual
page as well as some other files that jbuilder always installs because
they are used by other tools.

Since building the package.install files is very common, there is an
alias that refers to all these files. It is the install alias. In
partucilar, since "jbuilder build @install" is the most commonly run
command, "@install" is the default target if none are given.

After building the packages, we can ask jbuilder to install them with
"jbuilder install". Now we can use the "math" tool directly or consult
the manual page.

At the moment, opam doesn't know about jbuilder. So before we
distribute our packages, we have to write in the opam files how to
build our packages with jbuilder. The line to write is the same for
all packages using jbuilder, so you can simply copy paste it
everywhere. It is "jbuilder build -p name -j jobs". So that see that
"name" and "jobs" are not between double quotes, this is because they
are variables filled by opam. "name" will be replaced by the package
name, so "math" here and "jobs" by the number of jobs allocated by
opam to build the package.

The "-p" option is very important and must always be used in opam
files. The long for of this option is "--for-release-of-package". It
has two effects: first, it sets jbuilder into a more deterministic
mode. For instance, it disable the lookup for a jbuild-workspace file
and assume that the root of the workspace is wherever jbuilder is
started. This is to ensure that when a user install our package with
opam, jbuilder won't accidently pick up the wrong jbuild-workspace
file. If in the future we make jbuilder look at environment variable
or read global configuration files, we'll make sure that "-p" disable
this as well.

The second effect of this option is to filter the contents of the
jbuild files in the workspace: it will ignore any stanza that is part
of a different package that the current one. For instance, when
installing the "math-bin" package with opam, we want to use the "math"
library that was previously installed by opam and not recompile the
one in src. When given "-p math-bin", jbuilder will basically ignore
the contents of src/jbuild. So it will think that the workspace
doesn't contain a "math" library and will always look for it in the
installed world.

Then we can also write a "build-test" line to tell opam how to build
and run the tests if the user ask for them. We simply replace "build"
by "runtest".

We do the exact same thing for the "math-bin" package. The only
difference is that this package has dependencies so we need to write
them down.

That's essentially all we have to do for the packaging part. The last
thing I recommend to do is to write the following pkg/pkg.ml file with
these two lines. It will allow to use the "topkg" command line tool on
the project. This tool allows to automate the steps for creating a
release, uploading it with the release notes and documentation and
publishing it in the main opam repository. This is really nice when
you do a lot of releases as doing all this manually is very boring.

Eventually, we shouldn't even have to write this file, as topkg will
be able to recognize a jbuilder project.


That's all for this video. I hope that it will help you understand
better how jbuilder works and how you can use it your projects. There
are many features of jbuilder I haven't talked about, you can find
more about them in the online manual and if you have questions, don't
hesitate to ask, either on the github project or on discuss.ocaml.org.
